## 1.运算符优先级

位置在上者优先级高于下者，由左至右

- 逻辑运算符 NOT 非
- 算术运算符（*, /, %）
- 算术运算符（+, -）
- 相对关联运算符（<, >, <=, >=）
- 逻辑运算符 AND 且
- 逻辑运算符 OR 或
- 赋值运算符

实例：

```c++
!val%2//不正确
```

想法：利用val模以2来判断val的奇偶性，val为偶数时，模运算后余0,为奇数余非零，再取反。

实际上：NOT运算优先级最高，先运行`!val`，除非val为零，其结果都为`false`

应该为

```c++
!(val%2)//正确
```



## 2.指针

```c++
int val=1024;	//定义一个int对象并赋值1024
int * p;		//定义了一个int型的对象的指针
val;			//核估val的值
&val;			//核估val所在的内存地址
p=&val;			//指针对象指向val的内存地址
```

- 要存取一个由指针寻址的对象，需要对该指针进行提领（dereference）操作，也就是取得“位于该指针所在内存地址上”的对象，在指针前使用 * 号。

```c++
*p;//核定p指针所指内存地址上对象的值
```



- 指针可能并不指向任何对象:null指针

```c++
int * p=0;//
```



## 3.传值、传址

### 传值

```c++
#include<iostream>
using namespace std;

void swap(int val1,int val2)
{
    int tem;
    tem=val1;
    val1=val2;
    val2=tem;
}

int main()
{
    int a=1;
	int b=2;
    cout<<"a:"<<a<<"b:"<<b<<endl;
    swap(a,b);//
    cout<<"a:"<<a<<"b:"<<b<<endl;
    
    return 0;
}
```

  - 采用传值的方式，传给swap函数的对象被复制了一份，将实参a、b的分别拷贝给val1、val2，对复制品的更改与原对象a、b之间没有关系。swap完成了对val1、val2的交换，但程序结束后val1、val2被销毁，不会对实参产生影响
  - 调用一个函数时，会在内存中建立一块特殊区域，称为“程序栈（program stack）“，这块特殊区域提供了每个函数参数的存储空间，也提供了函数内定义的局部对象的存储空间，一旦函数执行完，这块内存就会被释放掉


### 传址

```c++
#include<iostream>
using namespace std;

void swap(int &val1,int &val2)//引用传递
{
    int tem;
    tem=val1;
    val1=val2;
    val2=tem;
}

void swap(int *val1,int *val2)//地址传递
{
    int tem;
    tem=*val1;
    *val1=*val2;
    *val2=tem;
}

int main()
{
    int a=1;
	int b=2;
    cout<<"a:"<<a<<"b:"<<b<<endl;
    swap(a,b);//
    cout<<"a:"<<a<<"b:"<<b<<endl;
    
    return 0;
}
```

- 地址传递：把实参的存储地址传送给对应的形参，从而使得形参指针和实参指针指向同一个地址。实际上，传地址依然是实参到形参的拷贝，只不过交换的是两个实参的内存地址，因此，被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参。
- 引用传递：没有实参到形参的拷贝，直接将实参a、b传入swap中。以引用为参数，则既可以使得对形参的任何操作都能改变相应的数据，又使得函数调用显得方便、自然。引用传递方式是在函数定义时在形参前面加上引用运算符“&”。传引用，在中间产生的临时对象会记住所有动作，就算函数的栈帧结构全部销毁，并不会影响到引用参数的临时对象

## 4.引用

```c++
int val=1024;
int * p=&val;//定义一个整形指针p指向val的内存地址
int & r=val;//定义一个引用代表val
```
```c++
int val2=4096;
r=val2;
```
实际上是把val2的值赋值给r引用所代表的对象val

```c++
p=&r;
```
实际上是让指针p指向r引用代表的对象val的地址

## 5.生存空间

- 函数内定义的对象，只存活于函数执行之际
- 若将这些局部对象的地址返回，会导致执行错误
- 函数临时位于程序栈上，局部对象在此区域中，函数执行完毕，这块区域内容被清除
- 若以传值方式将局部对象返回，不会产生问题，因为返回的是对象的复制品，其在函数之外依然存在



- 对象在程序内的生活区域称为该对象的scope（生存空间）
- local scope（局部生存空间）
- 对象在函数以外声明，具有file scope或者叫static scope，此对象从声明点到文件尾端都是可用的

## 6.动态内存管理

- local scope与file scope由系统自动管理
- dynamic extent（动态范围）的内存由程序的自由空间free store配置而来，也叫heap memory堆内存，由程序员自行管理，配置通过new表达式达成，释放由delete完成



```c++
int * p=new int;
```

在堆区上配置一个型别为int的对象，再将其地址赋给指针p

```c++
int * p=new int(1024);
```

动态配置并初始化

```c++
int * p=new int[24];
```

在堆区配置一数组，拥有24个int类元素，将此数组首地址赋给指针p

**c++没有任何语法实现在heap上配置数组并初始化**

```c++
delete p;
```

释放

```c++
delete [] p;
```

释放数组对象

无需检验指针p是否为零`if(p!=0){delete p}`，编译器会替我们检查



## 7.inline内联函数

- 一些函数被频繁调用，不断地有函数入栈，即**函数栈**，会造成栈空间或**栈内存**的大量消耗。为了解决这个问题，特别的引入了**inline修饰符**，表示为**内联函数**。
- 栈空间就是指放置程式的局部数据也就是函数内数据的内存空间，在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足所造成的程式出错的问题，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。

```c

#include <stdio.h>  
 
//函数定义为inline即:内联函数  
inline char* dbtest(int a) 
{  
	return (i % 2 > 0) ? "奇" : "偶";  
}   
  
int main()  
{  
	int i = 0;  
	for (i=1; i < 100; i++) 
	{  
		printf("i:%d    奇偶性:%s /n", i, dbtest(i));      
	}  
} 
```

 上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成(i%2>0)?"奇":"偶"这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。



- **关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用**。inline 是一种 **“用于实现的关键字”** 

  ```c++
  inline void Foo(int x, int y); // inline 仅与函数声明放在一起
  void Foo(int x, int y)
  {
  }
  
  void Foo(int x, int y);
  inline void Foo(int x, int y) // inline 与函数定义体放在一起
  {
  }
  ```

  

-  **inline只适合涵数体内代码简单的函数数使用**，不能包含复杂的结构控制语句例如while、switch，并且**内联函数本身不能是直接递归函数**(自己内部还调用自己的函数)。

- **内联是以代码膨胀（复制）为代价**，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收
  获会很少。另一方面，**每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间**。
- 以下情况不宜使用内联：
  - （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高
  - （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大
























