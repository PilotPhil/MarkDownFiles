## 1.使用数据库时QSqlTableModel显示时间格式不满足要求

- 详情：QSqlTableModel显示数据库中的datatime（格式为：yyyy-MM-dd hh:mm:ss）时，显示为yyyy-MM-dd hh:mm，缺少了==秒==的显示

- 解决方法：==重写一个继承于QSqlTableModel类的data函数==

- [原网页：QSqlTableModel的日期显示问题](http://www.qtcn.org/bbs/simple/?t50562.html)

```c++
//myQsqlTableModel.h
#include <QSqlTableModel>
#include <QObject>
#include <QDateTime>

class myQsqlTableModel : public QSqlTableModel
{
public:
    myQsqlTableModel();

    QVariant data(const QModelIndex &idx, int role) const;
};
```

```c++
//myQsqlTableModel.cpp
#include "myqsqltablemodel.h"

myQsqlTableModel::myQsqlTableModel()
{

}

QVariant myQsqlTableModel::data(const QModelIndex &idx, int role) const
{
    if(!idx.isValid())
        return QVariant();

    QVariant vt=QSqlTableModel::data(idx,role);

    if(QVariant::DateTime==vt.type())
        return vt.toDateTime().toString("yyyy-MM-dd hh:mm:ss");
    return vt;
}
```
## 2.查询数据表大小遇到`QSqlQuery::value: not positioned on a valid record`错误

```c++
void Widget::tableSpace()
{
    QString sql="SELECT (sum(DATA_LENGTH)+sum(INDEX_LENGTH))/1048576 "
                "FROM information_schema.TABLES where TABLE_SCHEMA='ship';";
    QSqlQuery query;
    query.exec(sql);
    qDebug()<<query.value(0);
}
```

==解决方法：QSqlQuery返回的数据集，record是停在第一条记录之前的。所以，你获得数据集后，必须执行next()或first()到第一条记录，这时候record才是有效的。否则，exec完直接value肯定报这个错==

```c++
void Widget::tableSpace()
{
    QString sql="SELECT (sum(DATA_LENGTH)+sum(INDEX_LENGTH))/1048576 "
                "FROM information_schema.TABLES where TABLE_SCHEMA='ship';";
    QSqlQuery query;
    query.exec(sql);
    
    query.next();//
    
    qDebug()<<query.value(0);
}
```

## 3.设置按钮按下后不弹起
```c++
ui->button->setCheckable(true);
```

## 4.tableview设置表头隐藏
```c++
ui->tableview->horizontalHeader()->setVisible(false);
```

## 5.设置表格宽度自适应
```c++
ui->tableView->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);
```

## 6.tableview自动更新，滚动条保持在最下方
```c++
ui->tableView->scrollToBottom();
```

## 7.mysql字符集为utf8 数据库内中文字符在Qt中显示为乱码
```c++
QTextCodec::setCodecForLocale(QTextCodec::codecForName("UTF8");
```

## 8.多核编译
菜单栏->工具-> 选项->构建与运行->构建套件->点击自动检测内容->在同一页面找到 Environment ->点击change ->在弹出的窗口

添加`MAKEFLAGS=-j4`即可

**==-j4 :表示cup四个核数加入编译==***

## 9.qRegisterMetaType的使用
如果是自己定义的类型如果想使用signal/slot来传递的话，则没有这么简单。直接使用的话，会产生下面这种错误：

`QObject::connect: Cannot queue arguments of type 'TextAndNumber' (Make sure 'TextAndNumber' is registed using qRegisterMetaType().) `

**原因**：当一个signal被放到队列中（queued）时，它的参数(arguments)也会被一起一起放到队列中（queued起来），这就意味着参数在被传送到slot之前需要被拷贝、存储在队列中（queue）中；为了能够在队列中存储这些参数(argument)，Qt需要去construct、destruct、copy这些对象，而**为了让Qt知道怎样去作这些事情，参数的类型需要使用qRegisterMetaType来注册（如错误提示中的说明）**

**步骤**：(以自定义TextAndNumber类型为例）
- 自定一种类型，在这个类型的顶部包含：`#include <QMetaType>`
- 在类型定义完成后，加入声明：`Q_DECLARE_METATYPE(TextAndNumber);`
- 在main()函数中注册这种类型：`qRegisterMetaType<TextAndNumber>("TextAndNumber");`
- 如果还希望使用这种类型的引用，可同样要注册：`qRegisterMetaType<TextAndNumber>("TextAndNumber&");`



